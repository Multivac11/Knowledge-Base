class b extends Error{constructor(e){super(e),this.name="TimeoutError"}}class T extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const f=r=>globalThis.DOMException===void 0?new T(r):new DOMException(r),E=r=>{const e=r.reason===void 0?f("This operation was aborted."):r.reason;return e instanceof Error?e:f(e)};function g(r,e){const{milliseconds:o,fallback:u,message:i,customTimers:m={setTimeout,clearTimeout}}=e;let c,s;const l=new Promise((a,n)=>{if(typeof o!="number"||Math.sign(o)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${o}\``);if(e.signal){const{signal:t}=e;t.aborted&&n(E(t)),s=()=>{n(E(t))},t.addEventListener("abort",s,{once:!0})}if(o===Number.POSITIVE_INFINITY){r.then(a,n);return}const d=new b;c=m.setTimeout.call(void 0,()=>{if(u){try{a(u())}catch(t){n(t)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?a():i instanceof Error?n(i):(d.message=i??`Promise timed out after ${o} milliseconds`,n(d))},o),(async()=>{try{a(await r)}catch(t){n(t)}})()}).finally(()=>{l.clear(),s&&e.signal&&e.signal.removeEventListener("abort",s)});return l.clear=()=>{m.clearTimeout.call(void 0,c),c=void 0},l}export{g as p};
